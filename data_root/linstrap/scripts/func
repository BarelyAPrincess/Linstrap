#!/bin/bash

yes() {
    [ $1 ] && eval "$1=0" || echo -n 0
}

no() {
    [ $1 ] && eval "$1=1" || echo -n 1
}

is() {
    [ $1 ] && eval "CV=\${$1}" || CV=$1
    [ "$CV" == "0" ] || return 0
}

check_var() {
	eval "[ ! \${$1} ] && error \"No! The variable '$1' is unset. Is it declared in the '${LINSTRAP_SCRIPTS}/env' script?\""
}

var_dump() {
	echo -n "{$1=\"$(eval "echo -n \${$1}")\"}"
}

check_file() {
	if [ ! -f "$1" ]; then
		error "\nyes... :( The$2 file \"$1\" does not exist!"
	fi
}

sterilize_bool() {
    eval "CV=\${$1}"
    case $CV in
        "1"|"yes"|"true")
            EV=$(yes)
            ;;
        "0"|"no"|"false"|"")
            EV=$(no)
            ;;
        *)
            # Is there a way to prevent this from executing malicious code?
            eval "$CV &>/dev/null"
            EV="$?"
            ;;
    esac

    [ $1 ] && eval "$1=\"$EV\"" || return $EV
}

echo() {
  if [ $# -eq 0 ]; then
    builtin echo
  else
    OPTIONS="-e"
    VAR=""
    eval set -- "$(getopt -n "echo" -o neE --long version --long help -- "$@")"
    while :; do
      if [ "$1" == "--help" ]; then
        builtin echo --help
        exit $?
      elif [ "$1" == "--version" ]; then
        builtin echo --version
        exit $?
      elif [ "$1" == "--" ]; then
        shift
        VAR="$*"
        break;
      else
        OPTIONS="$OPTIONS $1"
      fi
      shift
    done

    if [ "$(LC_ALL=C type -t parse_color)" == "function" ]; then
      VAR="$(parse_color "$VAR")"
    else
      VAR="${VAR//[&@][0-9A-Za-z]/}"
    fi

    builtin echo $OPTIONS "$VAR"
  fi
}

last_arg() {
  for i; do :; done
  builtin echo -ne $i
}

is_builtin() {
    [ "$(LC_ALL=C type -t ${1})" == "builtin" ]
}

join_by() { local d="$1"; shift; local f="$1"; shift; printf %s "$f" "${@/#/$d}"; }

crash() {
    echo "&4$@"
    exit 1
}

sterilize_bool USE_COLOR

case "$TERM" in
    xterm-color|*-256color ) USE_COLOR=$(yes);;
esac

# Check if setting the color causes an error
if [ $USE_COLOR == "0" ] && ! tput setaf 1 >&/dev/null; then
    USE_COLOR=$(no)
fi

if is USE_COLOR; then
    [ $CODE_DEF ] || CODE_DEF="\e[96m"
    [ $CODE_GOOD ] || CODE_GOOD="\e[1;36m"
    [ $CODE_BLINK ] || CODE_BLINK="\e[5m"
    [ $CODE_ERROR ] || CODE_ERROR="\e[1;41;97m"
    [ $CODE_RESET ] || CODE_RESET="\e[39;0m"
fi

msgbox() {
  declare -i WIDTH="$1"
  shift
  msg " ╔═$(repeat "═" $WIDTH)═╗ "
  for STR in "$@"; do
    msg " ║ $CODE_GOOD$(alignCenter "$STR" "$WIDTH";)$CODE_RESET ║"
  done
  msg " ╚═$(repeat "═" $WIDTH)═╝ "
}

msg() {
    echo -e "$CODE_DEF $1 $CODE_RESET"
}

alignCenter() {
    LM=$((${2}/2-${#1}/2))
    RM=$LM
    [ $((${#1}%2)) == "1" ] && RM=$((RM-1))
    echo -en "`printf '%*s' $LM`$1`printf '%*s' $RM`"
}

repeat() {
  for i in $(seq $2); do
    builtin echo -n "$1"
  done
}

error() {
    echo
    echo
    echo -e "        $CODE_ERROR ╔════════════════════════════════════════════════════════════════════╗ $CODE_RESET        ">&2
    echo -e "        $CODE_ERROR ║ $CODE_BLINK$(alignCenter "!!! ERROR ERROR ERROR ERROR !!!" "66";)$CODE_RESET$CODE_ERROR ║ $CODE_RESET        ">&2
    echo -e "        $CODE_ERROR ║                                                                    ║ $CODE_RESET        ">&2
    echo -e $1 | while read line; do
        echo -e "        $CODE_ERROR ║ $(alignCenter "$line" "66";) ║ $CODE_RESET        ">&2
    done
    echo -e "        $CODE_ERROR ╚════════════════════════════════════════════════════════════════════╝ $CODE_RESET        ">&2

    echo
    echo
    exit 1
}